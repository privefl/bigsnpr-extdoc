[["preprocessing.html", "Chapter 3 Preprocessing 3.1 Conversion and quality control of PLINK files 3.2 Imputation 3.3 Exercise: preprocessing", " Chapter 3 Preprocessing In this section, I am including conversion, quality control and imputation. 3.1 Conversion and quality control of PLINK files PLINK is very efficient for conversion and quality control of multiple formats, so I have decided just using it. In {bigsnpr}, I provide some wrappers to PLINK for ease of use: download_plink() and download_plink2() for downloading the latest stable versions of PLINK 1.9 and 2.0. snp_plinkQC() for quality control (QC) and conversion to bed/bim/fam. snp_plinkKINGQC() for QC on relatedness based on KING-robust kinship estimator. Using make.bed = FALSE allows for computing related pairs only, i.e. reporting a data frame without producing new bed/bim/fam files. snp_plinkIBDQC() for QC based on identity-by-descent (IBD) computed by PLINK using its method-of-moments. snp_plinkRmSamples() for producing new PLINK files after having removed some individuals. For any other PLINK function, I recommend calling PLINK directly from thanks to system calls and package {glue}, e.g. plink &lt;- download_plink(&quot;tmp-data&quot;) system(glue::glue( &quot;{plink} --version&quot; )) #&gt; PLINK v1.90b6.21 64-bit (19 Oct 2020) 3.2 Imputation Note that most functions from {bigstatsr} and {bigsnpr} dont handle missing values. Simple imputation (e.g. by the mean) of a double FBM can be performed by blocks using e.g. as explained in this vignette. In {bigsnpr}, to perform simple imputation of genotyped data, you can use snp_fastImputeSimple(). You can also use snp_fastImpute() that uses XGBoost models to impute genotyped data (slower but still fast enough, described in Priv√© et al. (2018)). 3.3 Exercise: preprocessing For the exercises, we will use the data provided in Reed et al. (2015). This can be downloaded using url &lt;- &quot;https://www.mtholyoke.edu/courses/afoulkes/Data/statsTeachR/&quot; sapply(paste0(url, &quot;GWAS_data&quot;, c(&quot;.bed&quot;, &quot;.bim&quot;, &quot;.fam&quot;)), runonce::download_file, dir = &quot;tmp-data&quot;) #&gt; https://www.mtholyoke.edu/courses/afoulkes/Data/statsTeachR/GWAS_data.bed #&gt; &quot;tmp-data/GWAS_data.bed&quot; #&gt; https://www.mtholyoke.edu/courses/afoulkes/Data/statsTeachR/GWAS_data.bim #&gt; &quot;tmp-data/GWAS_data.bim&quot; #&gt; https://www.mtholyoke.edu/courses/afoulkes/Data/statsTeachR/GWAS_data.fam #&gt; &quot;tmp-data/GWAS_data.fam&quot; For some reason, this data is not ordered by chromosome and position; we can use PLINK to get an ordered version of this using library(bigsnpr) plink &lt;- download_plink(&quot;tmp-data&quot;) system(glue::glue( &quot;{plink} --bfile tmp-data/GWAS_data&quot;, &quot; --make-bed --out tmp-data/GWAS_data_sorted&quot; )) #&gt; [1] 0 As you can see from PLINK output, this data contains 1401 individuals and 500,000 variants, with a few missing values. We can then perform some quality control using bedfile2 &lt;- snp_plinkQC(plink, &quot;tmp-data/GWAS_data_sorted&quot;) 404,663 variants are remaining after this quality control; we can then read this data into an R object called bigSNP using (rds &lt;- snp_readBed2(bedfile2, ncores = nb_cores())) #&gt; [1] &quot;C:\\\\Users\\\\au639593\\\\Desktop\\\\bigsnpr-extdoc\\\\tmp-data\\\\GWAS_data_sorted_QC.rds&quot; obj.bigsnp &lt;- snp_attach(rds) str(obj.bigsnp, max.level = 2) #&gt; List of 3 #&gt; $ genotypes:Reference class &#39;FBM.code256&#39; [package &quot;bigstatsr&quot;] with 16 fields #&gt; ..and 26 methods, of which 12 are possibly relevant: #&gt; .. add_columns, as.FBM, bm, bm.desc, check_dimensions, #&gt; .. check_write_permissions, copy#envRefClass, initialize, #&gt; .. initialize#FBM, save, show#envRefClass, show#FBM #&gt; $ fam :&#39;data.frame&#39;: 1401 obs. of 6 variables: #&gt; ..$ family.ID : int [1:1401] 10002 10004 10005 10007 10008 10009 10010 10011 10012 10013 ... #&gt; ..$ sample.ID : int [1:1401] 1 1 1 1 1 1 1 1 1 1 ... #&gt; ..$ paternal.ID: int [1:1401] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..$ maternal.ID: int [1:1401] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..$ sex : int [1:1401] 1 2 1 1 1 1 1 2 1 2 ... #&gt; ..$ affection : int [1:1401] 1 1 2 1 2 2 2 1 2 -9 ... #&gt; $ map :&#39;data.frame&#39;: 404663 obs. of 6 variables: #&gt; ..$ chromosome : int [1:404663] 1 1 1 1 1 1 1 1 1 1 ... #&gt; ..$ marker.ID : chr [1:404663] &quot;rs12565286&quot; &quot;rs3094315&quot; &quot;rs2980319&quot; &quot;rs2980300&quot; ... #&gt; ..$ genetic.dist: int [1:404663] 0 0 0 0 0 0 0 0 0 0 ... #&gt; ..$ physical.pos: int [1:404663] 721290 752566 777122 785989 798959 947034 949608 1018704 1041700 1129672 ... #&gt; ..$ allele1 : chr [1:404663] &quot;G&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; ... #&gt; ..$ allele2 : chr [1:404663] &quot;C&quot; &quot;T&quot; &quot;T&quot; &quot;G&quot; ... #&gt; - attr(*, &quot;class&quot;)= chr &quot;bigSNP&quot; Recall that this data contains some missing values; you can get some counts per variant using G &lt;- obj.bigsnp$genotypes counts &lt;- big_counts(G) counts[, 1:8] #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; 0 1247 958 1057 988 831 1201 496 386 #&gt; 1 131 362 316 370 502 115 676 730 #&gt; 2 6 66 28 25 67 7 165 216 #&gt; &lt;NA&gt; 17 15 0 18 1 78 64 69 hist(nbNA &lt;- counts[4, ]) We can e.g. perform a quick imputation by the mean using G2 &lt;- snp_fastImputeSimple(G, method = &quot;mean2&quot;, ncores = nb_cores()) big_counts(G2, ind.col = 1:8) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; 0 1247 958 1057 988 831 1201 496 386 #&gt; 1 131 362 316 370 502 115 676 730 #&gt; 2 6 66 28 25 67 7 165 216 #&gt; &lt;NA&gt; 0 0 0 0 0 0 0 0 #&gt; 0.01 0 0 0 0 0 0 0 0 #&gt; 0.02 0 0 0 0 0 0 0 0 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 196 rows ] big_counts(G, ind.col = 1:8) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] #&gt; 0 1247 958 1057 988 831 1201 496 386 #&gt; 1 131 362 316 370 502 115 676 730 #&gt; 2 6 66 28 25 67 7 165 216 #&gt; &lt;NA&gt; 17 15 0 18 1 78 64 69 G still has missing values, but G2 does not. Note that both are using the same data, the difference is that they using a different code to decode the underlying data: G$code256 #&gt; [1] 0 1 2 NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #&gt; [24] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA #&gt; [47] NA NA NA NA #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 206 entries ] G2$code256 #&gt; [1] 0.00 1.00 2.00 NA 0.00 1.00 2.00 0.00 0.01 0.02 0.03 0.04 0.05 0.06 #&gt; [15] 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 #&gt; [29] 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 #&gt; [43] 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 #&gt; [ reached getOption(&quot;max.print&quot;) -- omitted 206 entries ] To always use the new code, you need to save it using obj.bigsnp$genotypes &lt;- G2 snp_save(obj.bigsnp) You can re-attach this data in another R session later using snp_attach(\"tmp-data/GWAS_data_sorted_QC.rds\"). "]]
