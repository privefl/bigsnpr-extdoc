[["preprocessing.html", "Chapter 3 Preprocessing 3.1 Conversion and quality control of PLINK files 3.2 Imputation", " Chapter 3 Preprocessing In this section, Im including conversion, quality control and imputation. 3.1 Conversion and quality control of PLINK files PLINK is very efficient for conversion and quality control of multiple formats, so I have decided just using it. In {bigsnpr}, I provide some wrappers to PLINK for ease of use: download_plink() and download_plink2() for downloading the latest stable versions of PLINK 1.9 and 2.0. snp_plinkQC() for quality control (QC) and conversion to bed/bim/fam. snp_plinkKINGQC() for QC on relatedness based on KING-robust kinship estimator. Using make.bed = FALSE allows for computing related pairs only, i.e. reporting a data frame without producing new bed/bim/fam files. snp_plinkIBDQC() for QC based on identity-by-descent (IBD) computed by PLINK using its method-of-moments. snp_plinkRmSamples() for producing new PLINK files after having removed some individuals. For any other PLINK function, I recommend calling PLINK directly from thanks to system calls and package {glue}, e.g. plink &lt;- download_plink(&quot;tmp-data&quot;) system(glue::glue( &quot;{plink} --version&quot; )) #&gt; PLINK v1.90b6.21 64-bit (19 Oct 2020) 3.2 Imputation Note that most functions from {bigstatsr} and {bigsnpr} dont handle missing values. Simple imputation (e.g. by the mean) of a double FBM can be performed by blocks using e.g. X &lt;- FBM(20, 20, init = rnorm(400)) X[1, ] &lt;- NA big_apply(X, function(X, ind) { # access a subset of columns as a standard R matrix X.sub &lt;- X[, ind, drop = FALSE] # get the location (i, j) of missing values ind_na &lt;- which(is.na(X.sub), arr.ind = TRUE) # compute the corresponding mean for each column j means &lt;- colMeans(X.sub, na.rm = TRUE)[ind_na[, 2]] # update j (relative to subset) to global &#39;ind&#39; ind_na[, 2] &lt;- ind[ind_na[, 2]] # fill positions with corresponding means X[ind_na] &lt;- means # here we don&#39;t want to return anything, so `NULL` NULL }, a.combine = &#39;c&#39;, ncores = 1) # can change `ncores` to `nb_cores()` #&gt; NULL X[1, ] #&gt; [1] 0.09724393 0.36171414 0.17143729 -0.41956734 -0.04667270 #&gt; [6] -0.07045853 0.10367424 0.13215657 -0.33489135 -0.19328032 #&gt; [11] -0.30679650 0.01190250 -0.37654967 -0.14073073 -0.19637132 #&gt; [16] 0.24731710 0.04299967 -0.12737193 -0.05137451 -0.19734480 big_scale()(X)$center #&gt; [1] 0.09724393 0.36171414 0.17143729 -0.41956734 -0.04667270 #&gt; [6] -0.07045853 0.10367424 0.13215657 -0.33489135 -0.19328032 #&gt; [11] -0.30679650 0.01190250 -0.37654967 -0.14073073 -0.19637132 #&gt; [16] 0.24731710 0.04299967 -0.12737193 -0.05137451 -0.19734480 In {bigsnpr}, to perform simple imputation of genotyped data, you can use snp_fastImputeSimple(). You can also use snp_fastImpute() that uses XGBoost models to impute genotyped data (slower but still fast enough, described in Priv√© et al. (2018)). "]]
